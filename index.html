<!DOCTYPE html>
<meta charset=utf-8 />
<title></title>

<style type="text/css">
    * {
        box-sizing: border-box;
    }
    body {
        font: 12px/1.5 sans-serif;
    }
    button {
        display: block;
        float: left;
    }
    .indicator {
        display: inline-block;
        vertical-align: middle;
        height: 1em;
        width: 1em;
        background: green;
    }
    .indicator.bad {
        background: red;
    }
</style>

<!-- <button><span class="text">Click me!</span> <span class="indicator"></span></button>
<button><span class="text">Click me!</span> <span class="indicator"></span></button>
<button><span class="text">Click me!</span> <span class="indicator"></span></button>
<button><span class="text">Click me!</span> <span class="indicator"></span></button>
<button><span class="text">Click me!</span> <span class="indicator"></span></button>
<button><span class="text">Click me!</span> <span class="indicator"></span></button> -->

<ul class="todo-list"></ul>

<script type="template" id="template-todo-list-item">
    <li class="todo-item"></li>
</script>

<script type="template" id="template-todo-list-item-content">
    <div class="todo-list-item-content">
        <span class="todo-list-item-content__text"></span>
        <input class="todo-list-item-content__done" type="checkbox">
    </div>
</script>

<script src="jquery.min.js"></script>
<script src="flight.js"></script>

<script type="text/javascript">
function merge(target, source) {
    return Object.keys(source).reduce(function (target, key) {
        target[key] = source[key];
        return target;
    }, target);
}

function inspect(v) {
    console.log(v);
    return v;
}

var withChildComponents = (function () {
    'use strict';

    var teardownEventCount = 0;

    function withBoundLifecycle() {
        this.defaultAttrs({
            teardownOn: ''
        });

        /**
         * If we were given a teardownOn event then listen out for it to teardown.
         */
        this.after('initialize', function () {
            if (this.attr.teardownOn) {
                if (this.attr.teardownOn === this.childTeardownEvent) {
                    throw new Error('Component initialized to listen for its own teardown event.');
                }
                this.on(document, this.attr.teardownOn, function () {
                    this.teardown();
                });
            }
        });
    }

    function withChildComponents() {
        /**
         * Give every component that uses this mixin a new, unique childTeardownEvent
         */
        this.before('initialize', function () {
            this.childTeardownEvent =
                this.childTeardownEvent ||
                withChildComponents.nextTeardownEvent();
        });

        /**
         * Before this component's teardown, tell all the children to teardown
         */
        this.before('teardown', function () {
            this.trigger(this.childTeardownEvent);
        });

        /**
         * Utility method for attaching a component with teardownOn.
         *
         * Takes Component (with attachTo method) plus destination and attrs arguments, which should
         * be the same as in a normal attachTo call.
         */
        this.attachChild = function (Component, destination, attrs) {
            attrs = attrs || {};
            if (!attrs.teardownOn) {
                attrs.teardownOn = this.childTeardownEvent;
            }
            var mixins = Component.prototype.mixedIn || [];
            var isMixedIn = (mixins.indexOf(withBoundLifecycle) > -1) ? true : false;
            (isMixedIn ?
                Component :
                Component.mixin(withBoundLifecycle)).attachTo(destination, attrs);
        };

    }

    withChildComponents.nextTeardownEvent = function () {
        teardownEventCount += 1;
        return '_teardownEvent' + teardownEventCount;
    };

    // Export the child lifecycle mixin
    withChildComponents.withBoundLifecycle = withBoundLifecycle;

    return withChildComponents;
}());

function withState() {
    this.initialState = function (newState) {
        this.stateDef = merge(this.stateDef || {}, newState);
    };

    this.setState = function (newState) {
        return merge(this.state, newState);
    };

    this.fromState = function (key) {
        return function () {
            return this.state[key]
        };
    };

    this.after('initialize', function () {
        var stateDef = (this.stateDef || {});
        var ctx = this;
        this.state = Object.keys(stateDef).reduce(function (state, k) {
            var value = stateDef[k];
            state[k] = (typeof value === 'function' ? value.call(ctx) : value);
            return state;
        }, {});

        setTimeout(function () {
            this.setState(this.state);
        }.bind(this), 0);
    });
}

function withBatchedUpdates() {
    var queue = [];
    function go() {
        while (queue.length) {
            queue.shift().call(queue.shift());
        }
    }
    this.batch = function (fn) {
        var len = queue.length;
        queue.push(fn, this);
        if (!len) {
            requestAnimationFrame(go);
        }
    };
    this.batchify = function (method) {
        var ctx = this;
        return function () {
            return ctx.batch(ctx[method]);
        };
    };
}

function withTimeout() {
    var timers = {};
    this.timeout = function (fn, time) {
        var ctx = this;
        return setTimeout(this.batchify(fn), time);
    };
    this.interval = function (fn, time) {
        var ctx = this;
        return setInterval(this.batchify(fn), time);
    };
};

function withRender() {
    function callTo(o, method /*, args... */) {
        var args = [].slice.call(arguments, 2);
        return function () {
            return o[method].apply(o, args);
        };
    }

    function call(fn) {
        return fn();
    }

    this.setupRender = function (selector, config) {
        if (!config) {
            config = selector;
            selector = undefined;
        }
        this.renderDefs = (this.renderDefs || []).concat({
            selector: selector,
            config: config
        });
    };

    this.render = function () {
        var newRenderStates = this.calculateRenderStates(this.renderConfigs);
        var previousRenderStates = this._prevRenderStates || [];
        newRenderStates
            .reduce(function (actions, newRenderState, i) {
                var $node = $(newRenderState.node || this.select(newRenderState.selector));
                var previousRenderState = previousRenderStates[i];
                return Object.keys(newRenderState.state)
                    .reduce(function (actions, k) {
                        var oldValue = (previousRenderState ? previousRenderState.state[k] : undefined);
                        var newValue = newRenderState.state[k];
                        if (oldValue !== newValue && typeof $node[k] === 'function') {
                            return actions.concat(
                                callTo($node, k, newValue)
                            );
                        }
                        return actions;
                    }, actions);
            }.bind(this), [])
            .forEach(call);
        this._prevRenderStates = newRenderStates;
    };

    this.calculateRenderState = function (renderConfig) {
        return Object.keys(renderConfig).reduce(function (memo, k) {
            var value = renderConfig[k];
            if (typeof value === 'function') {
                memo[k] = value.call(this);
            }
            if (typeof value === 'object' && !Array.isArray(value)) {
                memo[k] = this.calculateRenderState(value);
            }
            return memo;
        }.bind(this), {});
    };

    this.calculateRenderStates = function (renderConfigs) {
        return renderConfigs.map(function (renderConfig) {
            var state = this.calculateRenderState(renderConfig.config);
            return {
                node: renderConfig.node,
                selector: renderConfig.selector,
                config: renderConfig.config,
                state: state
            };
        }, this);
    };

    this.calculateRenderConfigs = function (renderDefs) {
        return renderDefs.map(function (renderDef) {
            return {
                node: (!renderDef.selector ? this.node : undefined),
                selector: renderDef.selector,
                config: renderDef.config
            };
        }, this);
    };

    this.fromAttr = function (key) {
        return function () {
            return this.attr[key];
        };
    };

    this.after('initialize', function () {
        this.renderConfigs = this.calculateRenderConfigs(this.renderDefs);
        this.render();
    });
}

var withTemplate = (function () {
    var cache = {};
    return function withTemplate() {
        this.renderTemplate = function (template) {
            cache[template] = (
                cache[template] ||
                document.getElementById('template-' + template).textContent.trim()
            );

            var wrapper = document.createElement('div');
            wrapper.innerHTML = cache[template];
            return wrapper.firstChild;
        };
    };
}());

var makeWithAutoRenderedTemplate = (function () {
    return function (autoRenderTemplate) {
        return function withAutoRenderedTemplate() {
            this.after('initialize', function () {
                this.node.appendChild(
                    this.renderTemplate(autoRenderTemplate)
                );
            });
        };
    };
}());

var withStateLinkedToRender = function () {
    this.after('initialize', function () {
        this.after('setState', this.batchify('render'));
    });
};

var Button = flight.component(withState, withBatchedUpdates, withRender, withTimeout, function button() {
    this.attributes({
        text: null,
        contentSelector: '.text',
        indicatorSelector: '.indicator'
    });

    this.initialState({
        working: false,
        counter: 0,
        todos: []
    });

    this.setupRender({
        attr: {
            'data-counter': function () {
                return this.state.counter;
            },
            disabled: function () {
                return (this.state.counter % 10 === 0);
            }
        }
    });

    this.setupRender('contentSelector', {
        text: function () {
            return (this.state.working ? 'Working...' : this.attr.text + ' ' + this.state.counter)
        }
    });

    this.setupRender('indicatorSelector', {
        attr: {
            class: function () {
                return [
                    'indicator',
                    (this.state.counter % 3 === 0 ? 'bad' : '')
                ].join(' ');
            }
        }
    });

    this.after('initialize', function () {
        this.on('click', this.batchify('startWorking'));
        this.after('setState', this.batchify('render'));
        this.interval(this.incrementCounter, Math.random() * 500 + 300);
    });

    this.incrementCounter = function () {
        this.setState({
            counter: this.state.counter + 1
        });
    };

    this.startWorking = function (e, data) {
        this.setState({
            working: !this.state.working
        });
    };
});

var Button = flight.component(withRender, withState, withBatchedUpdates, withTimeout, function button() {
    this.attributes({
        text: null,
        actionEvent: 'buttonClicked',
        bgcolor: 'red',
        contentSelector: '.content'
    });

    this.initialState({
        clicks: 0
    });

    this.setupRender({
        attr: {
            'data-action-event': this.fromAttr('actionEvent'),
            'data-clicks': function () {
                return this.state.clicks;
            }
        }
    });

    this.setupRender('contentSelector', {
        text: function () {
            return this.attr.text + ' ' + this.state.clicks
        }
    });

    this.after('initialize', function () {
        this.on('click', this.handleClick);
        this.after('setState', this.batchify('render'));
        this.interval(this.handleClick, Math.random () * 300 + 300);
    });

    this.handleClick = function () {
        this.setState({
            clicks: this.state.clicks + 1
        })
    };
});

var TodoList = flight.component(
    withTemplate,
    withBatchedUpdates,
    withChildComponents,
    function todoList() {
        this.attributes({
            todos: null
        });

        this.after('initialize', function () {
            this.attr.todos.forEach(this.addTodo, this);
        });

        this.addTodo = function (todo) {
            var node = this.renderTemplate('todo-list-item');
            this.node.appendChild(node);
            TodoItem.attachTo(node, todo);
        };
    }
);

var TodoItem = flight.component(
    withTemplate,
    makeWithAutoRenderedTemplate('todo-list-item-content'),
    withState,
    withRender,
    withStateLinkedToRender,
    withBatchedUpdates,
    function todoItem() {
        this.attributes({
            text: null,
            done: false,
            textSelector: '.todo-list-item-content__text',
            checkboxSelector: '.todo-list-item-content__done'
        });

        this.initialState({
            done: this.fromAttr('done')
        });

        this.setupRender('textSelector', {
            text: this.fromAttr('text')
        });

        this.setupRender('checkboxSelector', {
            attr: {
                checked: this.fromState('done')
            }
        });

        this.after('initialize', function () {
            this.on('change', {
                checkboxSelector: this.handleClick
            });
        });

        this.handleClick = function (event) {
            this.setState({
                done: event.target.checked
            });
        };
    }
);

// var interval = setInterval(function () {
document.addEventListener('DOMContentLoaded', function () {
    // var button = document.createElement('button');
    // document.body.appendChild(button);
    // Button.attachTo('button', {
    //     text: "Click me!"
    // });
    TodoList.attachTo('.todo-list', {
      todos: [
        { text: 'Make Flight amazing', done: false },
        { text: 'Drink more water', done: true },
        { text: 'Think about lunch', done: true },
        { text: 'Have lunch', done: false }
      ]
    });
});
// }, 1000);

/**
 * Random Ideas
 *
 * Higher order mixins are interesting — could they be used for all the state & attrs stuff:
 *     makeWithState({ ... }),
 *     makeWithAttributes({ ... })
 *
 *
 */

</script>

